# Practica 3: Navegación Local Esquivando Obstáculos Con Algoritmo VFF

## Desarollo del código y explicación en profundidad

```python
import WebGUI
import HAL
import Frequency
import time

import numpy as np
import cv2
```

Inicialmente contábamos con 3 imports necesarios para la interfaz gráfica del entorno de simulación, permitiéndonos interactuar con él y gestionar la frecuencia de ejecución.

Posteriormente he implementado la librería estándar de python time que nos permite manejar el tiempo. Y para poder procesar la información dada por el láser hacemos uso de los últimos import.

El objetivo es que el vehículo navegue de forma autónoma y reactiva siguiendo una serie de objetivos predefinidos, evitando obstáculos a su paso mediante un control basado en campos potenciales y un ajuste fino de la velocidad angular con PID.


## Enfoque general del control reactivo

La arquitectura del sistema sigue un esquema de control reactivo, donde cada iteración realiza las siguientes operaciones:

  1. Se obtienen 180 lecturas del sensor láser.

  2. Se calcula una fuerza repulsiva que aleja al robot de los obstáculos.

  3. Se determina una fuerza atractiva dirigida hacia el siguiente objetivo (goal).

  4. Se combinan ambas fuerzas ponderadas (α y β) para obtener la dirección final de movimiento.

  5. Un control PID sobre el ángulo resultante regula la velocidad angular w, mientras que la magnitud del vector ajusta la velocidad lineal v.

Este ciclo se ejecuta a una frecuencia de 10 Hz, lo que garantiza una reacción fluida y estable en el entorno simulado.

## Fuerzas atractiva y repulsiva

La fuerza atractiva se calcula en el marco del robot, apuntando al siguiente subobjetivo proporcionado por la interfaz:

Por otro lado, la fuerza repulsiva se obtiene directamente del láser:

## Control PID sobre la dirección angular

El controlador PID permite suavizar el giro, evitando movimientos bruscos:


```python
error = ang
integral += error
derivative = error - prev_error
prev_error = error

w = Kp * error + Ki * integral + Kd * derivative

```

## Evitación de obstáculos y selección de trayectoria lateral

Otra mejora importante fue la detección de espacio libre lateral mediante el análisis de los sectores izquierdo y derecho del láser.

Esto permitió que el robot eligiera correctamente por qué lado esquivar los obstáculos, evitando quedarse atascado.


## Dificultades encontradas y soluciones

  **1. Gestión de subobjetivos**
  Inicialmente el robot no avanzaba al siguiente objetivo, ya que la función goal.setReached(True) se ejecutaba demasiado pronto o demasiado tarde.
  Se solucionó añadiendo una condición dependiente de la distancia real al objetivo (dist_goal < 2.0).

  **2. Oscilaciones cerca de paredes u obstáculos múltiples**
  Lo eliminé mediante la suma ponderada adecuada de fuerzas.


## Resultados y comportamiento final

El robot consigue:

  - Avanzar de forma autónoma entre objetivos.

  - Detectar y esquivar obstáculos de manera fluida.

  - Ajustar su dirección sin perder estabilidad.

  - Completar el recorrido mostrado en el vídeo de referencia de RoboticsAcademy.

## Vídeo que muestra la ejecución


## License

This work is submitted under the **CC-BY-SA 4.0** license, meaning it can be shared and adapted as long as it is properly attributed and shared under the same terms.

## Autor

**Marina Antolínez Cabrero**

