# Practica 1: Implementacion de un Autómata de Estados Finito Reactivo

## Desarollo del código y explicación en profundidad

```python
import WebGUI
import HAL
import Frequency
import math
import random
import time
```

Inicialmente contábamos con 3 imports necesarios para la interfaz gráfica del entorno de simulación, permitiéndonos interactuar con él y gestionar la frecuencia de ejecución.

Posteriormente he implementado las tres siguientes librerías estándar de python, que nos permiten manipular operaciones matemáticas, generar aletoriedad y manejar el tiempo.

```python
AVANZANDO = 0
RETROCEDIENDO = 1
GIRANDO = 2
```

Dado que buscamos que nuestra aspiradora se mueva de manera pseudoaleatoria, la mejor manera es implementando una serie de estados finitos, en mi caso avanzando, girando y posteriormente retrocediendo.

De esta manera logramos una navegación pseudoaleatoria, que de forma estocástica (es decir introduciendo aletoridad para no seguir un camino fijo y predefinido), intentar cubrir la mayor parte del espacio de manera eficiente.


A continuación explicaré la importancia de cada estado en el desarrollo de la navegación:

### **1. AVANZANDO.**
   Lo primero comprueba que no nuestra aspiradora actualmente no está en contacto con ningun obstáculo.
   En el caso de que no lo esté, trazará una espiral para tratar de limpiar el mayor espacio posible.
   
   En mi caso, he decidido aplicar la aproximación de Arquímedes (espiral Archimedeana o Aritmética).
   Esta se caracteríza porque un punto se mueve a velocidad constante sobre una recta mientras esta recta gira con velocidad angular constante.
   Esto me ha ayudado a asegurarme de que no se queden espacios sin limpiar a la hora dentro de una msima subzona, y al mismo tiempo, poder controlar de manera correcta la velocidad, dado que un robot doméstico debería poder ser modulable.

   Inicialmente usé otras aproximaciones matemáticas pero una vez alcanzaba cierta velocidad, el robot tendía a moverse con mayor inercia y avanzaba mucho más rápido de lo esperado o sin realizar del todo el movimiento esperado. Es por ello que en el código este movimiento cuenta con tantos parámetros, que nos ayudan a ajustarla a lo necesario en la práctica.

   **Parámetros de espiral Archimedeana:**
   ```python
   r0 = 0.05           # radio inicial (m)
   k = 0.03            # cuánto crece r por radian (m/rad)
   omega = 0.6        # velocidad angular constante (rad/s)
   dt = 0.1            # 10 Hz -> 0.1 s por tick
   max_v = 0.7         # límite de velocidad lineal
   ```

   En el caso contrario, de haber detectado un obstáculo (pared u otro objeto), redirigimos el movimiento:

### **2. GIRANDO.**
   En este estado comprobamos en qué parte del robot se ha producido la colisión. Se obtiene un **ángulo de giro aleatorio dentro de un rango (30° a 60°)** y se gira en un sentido u otro dependiendo de qué bumper detectó la colisión.

   El cálculo de la orientación se realiza con la variable n_yaw, que indica ángulo que se normaliza:
   ```python
   n_yaw = (yaw_actual - yaw_inicio + math.pi) % (2*math.pi) - math.pi  # normalizamos el angulo [-pi,pi]
   ```

   Y finalmente:

### **3. RETROCEDIENDO.**
   En el enunciado de la práctica nos indican que nuestro robot debe retroceder durante 1.5 segundos, a la velocidad que nosotros consideremos.
   Obviamente y siguiendo la lógica de los estados anteriores, esta no será muy elevada para poder controlar debidamente el movimiento.

   En mi caso, durante el desarrollo de la práctica encontré una serie de problemas a la hora de medir correctamente el tiempo indicado.
   Si bien mi variable de tiempo máximo, al establecer que su valor sería 1.5, el estado finalizaba en 1.4 segundos. Pero al elevarla a 1.6 segundos conseguí que se ejecutará hasta 1.50 seg aproximamente.
   
   Como muestra la siguiente salida por terminal:

   ```bash
   Tiempo retro_t:
   1759598384. 7710395
   Tiempo: 1.304056167602539
   Estado: 1
   Tiempo time.time(): 1759598386.1753159
   Tiempo retro_t:
   1759598384. 7710395
   Tiempo: 1.4042854309082031
   Estado: 1
   Tiempo time.time(): 1759598386.2754552
   Tiempo
   retro t:
   1759598384.7710395
   Tiempo: 1.504431962966919
   Estado:
   1
   Estado:
   0
   Estado:
   0
   ```
   Esto es algo importante a tener en cuenta ya que como nuestro programa debe ejecutarse a 10 Hz, esto significa que cada 0.1 s se produce un tick, por lo que el tiempo medido puede verse afectado.

   Finalmente en este estado, debemos reiniciar las variables que afectan a nuestra espiral, ya que de esta manera nos aseguramos de no partir de un radio demasiado elevado y por ende, una velocidad lineal y angular elevada.


## Características clave

**Autómata de 3 estados:** Avanzando, Girando y Retrocediendo.

**Cobertura pseudoaleatoria estocástica** gracias a la aleatoriedad en los giros.

**Movimiento en espiral** de Arquímedes para el avance, con parámetros ajustables.

**Control de frecuencia** de ejecución a 10 Hz con Frequency.tick(10).

**Reactividad constante** sin uso de sleep en el bucle principal.

**Detección de obstáculos** con sensores de choque (Bumper).

**Orientación aproximada** usando yaw, sin depender de la odometría acumulada.


## Limitaciones del sistema

No utiliza mapas ni algoritmos robustos de localización.

El cálculo de posición mediante odometría no es fiable (acumula ruido) y no se emplea directamente.

La cobertura del área es estocástica: se logra eventual pero no garantizada al 100%.

## License

This work is submitted under the **CC-BY-SA 4.0** license, meaning it can be shared and adapted as long as it is properly attributed and shared under the same terms.

## Autor

**Marina Antolínez Cabrero**
