# Practica 4: Navegación Global con Algoritmo GPP

## Desarollo del código y explicación en profundidad

El código construye un planificador de ruta basado en un campo de costes que se propaga desde el objetivo (wavefront), al que se integra una penalización suave por proximidad a obstáculos para empujar la trayectoria hacia el centro de los pasillos. 
Se calcula un mapa binario de ocupación, se genera el campo de pesos con penalización integrada, se extrae una ruta por descenso de gradiente y se ofrece un modo de seguimiento en tiempo real que elige el siguiente movimiento localmente según el mínimo coste. 

Además, se incluyen impresiones de depuración para validar índices, valores finitos e interpretar el comportamiento del gradiente.

### Estructura general y convenciones

  - Mapa y grid: Se carga una imagen 400x400 y se convierte a binario donde 1 es obstáculo y 0 libre.

  - Coordenadas: Internamente, el grid se maneja como índices de NumPy en formato (fila, columna) y se respeta esa convención en la penalización y en la expansión. 
    En las funciones que trabajan “como si” fuese (x, y), se transpone explícitamente weights y grid para evitar cruces de índices.

  - Movimientos: Tomamos como referencia 8 vecinos (4 ortogonales y 4 diagonales) con costes 1 y sqrt(2), respectivamente.

### Penalización radial suave

  - Función: Crea un campo adicional donde cada celda libre cercana a un obstáculo recibe un coste extra proporcional a la cercanía.

  - Efecto deseado: Cerca de paredes el coste sube, en el centro baja, favoreciendo rutas centradas sin bordes duros. Aplicando cierta acumulación

### Wavefront con penalización integrada

  - Función: Propaga desde el objetivo usando una cola de prioridad (Dijkstra). Cada transición incorpora el coste de movimiento más la penalización de la celda destino.

  - Límite dinámico: Usa un umbral para evitar expandir infinitamente; aun así, la visualización y el campo se actualizan con normalización, mostrando más claro el gradiente hacia el objetivo.

  - Visualización: Se invierte la escala para que blanco sea “cerca del objetivo” y negro “lejos u obstáculos”.

### Extracción de la ruta por gradiente

  - Función: Descenso local buscando el vecino con menor coste.

  - Criterio de parada: Termina al alcanzar el objetivo o si no existe vecino con coste menor (mínimo local). 
    Imprime cada paso con su coste para validar que el gradiente decrece hacia el objetivo.

### Movimiento por gradiente en tiempo real

  - Función: Evalúa un celdas relativamente cercanas, a la celda actual del robot y elige la celda de menor coste como siguiente objetivo intermedio.

  - Control de movimiento: Convierte la celda seleccionada a coordenadas del mundo y aplica un control simple de orientación con saturación en velocidad angular y lineal, reduciendo V si el error angular es grande.

  - Escala y origen: Usa el desplazamiento y factor de escala para alinear las celdas del grid con el mundo; imprime distancia final para validar la precisión de llegada.

## Dificultades encontradas y soluciones

  **1. Inconsistencia entre las coordenadas del mundo físico y las del mapa**
  Aunque el sistema visual y el control del robot operaban en coordenadas (x, y), el algoritmo aplicaba los pesos como si fueran (y, x), lo que provocaba rutas invertidas, objetivos mal alcanzados y visualizaciones incoherentes. 
  Esta confusión se agravaba al recibir coordenadas del entorno en formato (y, x) y tratarlas como (x, y), generando desplazamientos incorrectos y errores en la interpretación del objetivo.

  **2. Aplicar correctamente la penalización a los obstáculos**
  Al principio la penalización se aplicaba después de la expansión del wavefront, lo que hacía que muchas celdas permanecieran con valores infinitos y la ruta se pegara a los bordes. Creando así inconsistencias. 
  Es por ello que detecté que esto debe ser aplicardo directamente al algoritmo.

  **3. Trazas para detectar posibles errores**
  Como he comentado en los apartados anteriores, el problema principal era no recibir correctamente los valores esperados. Esto ha podido ser progresivamente subsanado pudiendo imprimir en cada iteración cual era la información recibida.


## Vídeo que muestra la ejecución


https://github.com/user-attachments/assets/b939ad24-f3a3-4d71-a21f-029cbf7d0cd8



https://github.com/user-attachments/assets/ebc53356-a9f6-40b2-859e-b1fd885a14f5



## License

This work is submitted under the **CC-BY-SA 4.0** license, meaning it can be shared and adapted as long as it is properly attributed and shared under the same terms.

## Autor

**Marina Antolínez Cabrero**
