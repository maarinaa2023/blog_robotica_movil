# Práctica 5: Navegación Global y Exploración Reactiva Basada en Ocupación

## Desarrollo del código y explicación en profundidad

En esta práctica he implementado un sistema de exploración autónoma basado en una Finite State Machine (FSM) que combina:

  - Percepción reactiva mediante láser
  - Memoria espacial acumulada a través del Occupancy Grid
  - Selección inteligente de dirección según zonas desconocidas

El objetivo es que el robot explore un espacio sin necesidad de un objetivo global predefinido, intentando cubrir la mayor parte del mapa, evitando zonas visitadas y saliendo correctamente de esquinas o situaciones cíclicas.

Aunque el movimiento es reactivo, la inclusión del mapa permite un comportamiento mucho más inteligente, evitando que sea un simple seguidor de paredes o un robot que avanza sin memoria.

## Estructura general del sistema

**1. Mapa y ocupación**

El sistema mantiene un mapa probabilístico utilizando Log-Odds, que se actualiza con cada lectura del láser:

Por lo tanto, lo que haremos será proyectar todos los rayos sobre el grid. Actualizar celdas libres y ocupadas según la geometría del rayo.
Y finalmente cuando el robot se desplaze más de 0.3 m, almacenamos una actualización completa.

Con este mecanismo garantizamos que: 

  - el mapa nunca se queda “desfasado”,
  - los obstáculos detectados se almacenan a tiempo,
  - la planificación reactiva usa siempre datos coherentes.

**2. Coordenadas**

El sistema trabaja con dos espacios:

**- Coordenadas en el mundo real:** x,y,θ en metros y radianes, obtenidos del odómetro.
**- Coordenadas en el grid:** (fila, columna)

Esta conversión la realiza una función world_to_map(), que consigue: escalar los metros a la rejilla (grid), desplaza el origen,
garantiza que el robot siempre indexa dentro de los límites, y evita errores típicos como invertir ejes o mezclar (x, y) con (row, col).

**3. FSM de navegación**

El comportamiento está controlado mediante una máquina de estados con dos modos principales:

**ESTADO 1 — FORWARD**

El robot avanza mientras analiza continuamente los rayos del láser, evalúa las múltiples direcciones posibles y calcula puntuaciones basadas en cuánta zona desconocida ve.

Si la dirección frente a él es válida, continúa.

**ESTADO 2 — TURN**

El robot entra en modo giro cuando detecta un obstáculo frontal cercano, el sistema detecta estancamiento, todas las direcciones evaluadas indican ausencia de exploración o se encuentra en una esquina o un pasillo sin salida clara.

Este enfoque permite al robot orientarse de forma autónoma para descubrir nuevos sectores.


## Algoritmo de puntuación direccional

El núcleo de la toma de decisiones se encuentra en la función direction_score(), que evalúa varias orientaciones a partir del láser.
Ya que para cada dirección analizad, proyecto rayos virtuales, consulta el nivel de ocupación y la puntuaciñon de la celda en función de que tipo sea 
(desconocida, visitada u ocupada).

Avanzando a zonas inexploradas, evitando las ya mapeadas

## Problemas y como se han resuelto

**1. Coordenadas mapa/mundo y detección láser**
Al comienzo de la práctica, no entendía correctamente como parsear correctamnete el laser paar seguir obteneidno las salida esperada en el dibujo de neustro mapa, no invertido.
Y a su vez que la detección estuviese donde nos interesaba.

La solución consistió en invertir algunas coordendas a la hora de establecer las probabilidades, y girar nuestro ángulo de referencia en el laser 180º

**2. Evitar zonas ya exploradas**
Inicialmente el robot volvía a pasar por áreas visitadas, ignorando sectores desconocidos.

La solución consistió en penalizar mucho más las celdas conocidas, introducir evaluación angular en abanico, y obviamente aplicar memoria.

**3. Escape de esquinas**
Cuando todas las direcciones tienen puntuación ≤ 0: no hay zonas desconocidas a la vista, solo quedan celdas conocidas o paredes, de manera que existe una “trampa geométrica”.

La solución consistió en aplicar un giro amplio o aplicar una inversión del sentido de giro.

## Vídeo de la ejecución
El vídeo muestra varias ejecucciones:

https://github.com/user-attachments/assets/f30e9b4c-1aa7-4b31-849d-747757562928

## Licencia
This work is submitted under the CC-BY-SA 4.0 license, meaning it can be shared and adapted as long as it is properly attributed and shared under the same terms.

## Autor
Marina Antolínez Cabrero
