# Practica 2: Fórmula 1 mediante el uso de control reactivo PID 

## Desarollo del código y explicación en profundidad

```python
import WebGUI
import HAL
import Frequency
import time

import numpy as np
import cv2
```

Inicialmente contábamos con 3 imports necesarios para la interfaz gráfica del entorno de simulación, permitiéndonos interactuar con él y gestionar la frecuencia de ejecución.

Posteriormente he implementado la librería estándar de python time que nos permite manejar el tiempo.

Y para poder procesar la información dada por la cámara hacemos uso de los últimos import.


El objetivo de esta práctica es programar un coche de Fórmula 1 para que siga una línea roja central en la pista, ajustando sus velocidades lineal (V) y angular (W), de la manera más precisa posible. Es por ello que en mi caso he decidido usar un PD, ya que el sistema debe ser capaz de recorrer el circuito en el menor tiempo posible, manteniendo la estabilidad y evitando oscilaciones.

### Arquitectura general del control

La estructura del sistema está basada en un **bucle de control reactivo**, donde cada iteración realiza los siguientes pasos:

  1. Captura una imagen de la cámara frontal.

  2. Detecta la posición del color rojo (línea guía).

  3. Calcula el error como la distancia horizontal entre el centro de la imagen y el centroide de la línea.

  4. Ajusta la velocidad angular W mediante un control PD proporcional a dicho error.

  5. Modula la velocidad lineal V en función del error (menor velocidad en curvas).

  6. Si no se detecta línea roja, activa un modo de búsqueda autónomo.

Cabe destacar que el sistema opera a 20 Hz, asegurando una respuesta rápida sin sobrecargar la simulación.


### Controlador PD y parámetros dinámicos

El controlador implementado es un PD puro, que calcula su salida a partir del error y su derivada:

```python
def pid(error, dt, kp, kd):
    global error_anterior
    proporcional = kp * error
    derivativo = (error - error_anterior) / dt
    salida = proporcional + kd * derivativo
    error_anterior = error
    return salida
```

Estos valores se ajustaron empíricamente para conseguir un comportamiento estable, con mínimo sobreoscilamiento y buena respuesta ante curvas cerradas.

En mi caso, he implementado una adaptación dinámica de ganancias. De esta manera el sistema modula automáticamente los valores de kp y kd según la magnitud del error.
Esto permite que el control sea más agresivo en curvas (errores grandes) y más suave en rectas.

Aplicando el mismo principio a la velocidad del coche:

  - Rectas (error pequeño): 12 m/s
  - Curvas (error grande): 6 m/s

De esta forma, el coche desacelera automáticamente cuando se aproxima a una curva.

### Procesamiento de imagen

La detección de la línea roja se realiza mediante filtrado en el espacio HSV, aplicando dos rangos de color para cubrir ambos tonos de rojo (debido al salto de matiz entre 0° y 180° en HSV):

```python
rojo_bajo1 = np.array([0, 70, 30])
rojo_alto1 = np.array([25, 255, 255])
rojo_bajo2 = np.array([170, 70, 30])
rojo_alto2 = np.array([180, 255, 255])
```

Se combinan ambas máscaras y se calculan los momentos de la región roja para hallar su centroide (cx).
El error se obtiene comparando ese centro con el centro de la imagen.


### Modo búsqueda ante pérdida de línea

Una mejora clave respecto a versiones anteriores es la inclusión de un modo de recuperación automática cuando el coche pierde la referencia visual de la línea roja.

Cuando la cámara no detecta píxeles rojos durante varios ciclos consecutivos, el vehículo:

Reduce su velocidad lineal a 0.0 (detiene el avance).

  1. Gira sobre sí mismo (velocidad angular ±1.5) en la dirección del último error registrado.

  2. Si pasan más de 3 segundos sin detección, invierte el sentido de giro para buscar en el otro lado.

Este mecanismo garantiza evitar vacíos de control frente a errores de visión o tramos sin color.



## Limitaciones del sistema

No incluye control integral (I), por lo que no corrige errores persistentes (bias lateral).

Sensible a variaciones de iluminación o reflejos en la pista.

La búsqueda podría optimizarse con un pequeño avance lineal durante la rotación.

Sería posible añadir una estimación de curvatura local para predecir curvas antes de que aparezcan.


## Vídeo que muestra la ejecución




## License

This work is submitted under the **CC-BY-SA 4.0** license, meaning it can be shared and adapted as long as it is properly attributed and shared under the same terms.

## Autor

**Marina Antolínez Cabrero**
